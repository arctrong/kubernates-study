<!--METADATA {"title": "Practice"} -->

[[BACK](installation.html)]

----------------------------------------------------------------------------------------------------
[TOC]

----------------------------------------------------------------------------------------------------
_Jul 3, 2021_

# Creating Minikube cluster

[44:29](https://www.youtube.com/watch?v=X48VuDVv0do&t=2489s)

Starting minicube cluster.

> In non-Linux environment `--vm-driver` parameter must be used.

````shell
$ minikube start
.  .  .
* Done! kubectl is now configured to use "minikube" cluster and "default" namespace by default

$ minikube status
minikube
type: Control Plane
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured

$ kubectl get nodes
NAME       STATUS   ROLES                  AGE   VERSION
minikube   Ready    control-plane,master   14h   v1.20.7
````

There's the only Master Node so far.

----------------------------------------------------------------------------------------------------
# Main `kubectl` commands

[44:52](https://youtu.be/X48VuDVv0do?t=2692)


## Creating a Deployment

````shell
$ kubectl get pods
No resources found in default namespace.

$ kubectl get services
NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
kubernetes   ClusterIP   10.96.0.1    <none>        443/TCP   14h
````

````shell
$ kubectl create -h
Create a resource from a file or from stdin.

 JSON and YAML formats are accepted.
.  .  .
Available Commands:
.  .  .
  deployment          Create a deployment with the specified name.
  ingress             Create an ingress with the specified name.
  job                 Create a job with the specified name.
  secret              Create a secret using specified subcommand
  service             Create a service using specified subcommand.
.  .  .
````

But there's no `pod` in the `Available Commands`. That's because we are not creating Pods
directly. We use Deployments (abstraction over Pods) instead.

````shell
$ kubectl create deployment nginx-depl --image=nginx
deployment.apps/nginx-depl created
````

This used the latest version of the image on the [Docker Hub](https://hub.docker.com/).

````shell
$ kubectl get deployments
NAME         READY   UP-TO-DATE   AVAILABLE   AGE
nginx-depl   1/1     1            1           3m53s

$ kubectl get pods
NAME                          READY   STATUS    RESTARTS   AGE
nginx-depl-5c8bf76b5b-rmnmj   1/1     Running   0          5m2s

$ kubectl get replicasets
NAME                    DESIRED   CURRENT   READY   AGE
nginx-depl-5c8bf76b5b   1         1         1       6m59s
````


## Editing Deployments

````shell
$ kubectl edit deployment nginx-depl
````

The auto-generated file of the Deployment will be opened in the text editor. Let's, for example,
replace `- image: nginx` by `- image: nginx:1.20` and save the configuration.

````shell
deployment.apps/nginx-depl edited

greg@deimos:~$ kubectl get pods
NAME                          READY   STATUS    RESTARTS   AGE
nginx-depl-58f65d4b6f-hk44c   1/1     Running   0          30s

$ kubectl get replicasets
NAME                    DESIRED   CURRENT   READY   AGE
nginx-depl-58f65d4b6f   1         1         1       5m33s
nginx-depl-5c8bf76b5b   0         0         0       36m
````

We see the new Deployment with the new ID and that the old deployment has no replicas in its
ReplicaSet.


## Debugging Pods

[52:05](https://youtu.be/X48VuDVv0do?t=3125)

````shell
$ kubectl logs nginx-depl-58f65d4b6f-hk44c
/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration
/docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/
.  .  .
2021/07/03 10:06:05 [notice] 1#1: start worker process 35
````

Let's create another deployment and look at its log:

````shell
$ kubectl create deployment mongo-depl --image=mongo
deployment.apps/mongo-depl created

$ kubectl get pods
NAME                          READY   STATUS    RESTARTS   AGE
mongo-depl-5fd6b7d4b4-jj4b5   1/1     Running   0          47s
nginx-depl-58f65d4b6f-hk44c   1/1     Running   0          88m

$ kubectl logs mongo-depl-5fd6b7d4b4-jj4b5
{"t":{"$date":"2021-07-03T11:34:44.399+00:00"},"s":"I",  "c":"CONTROL",  "id":23285,   "ctx":"main",
"msg":"Automatically disabling TLS 1.0, to force-enable TLS 1.0 specify --sslDisabledProtocols 'none'"}
.  .  .
{"t":{"$date":"2021-07-03T11:34:45.075+00:00"},"s":"I",  "c":"NETWORK",  "id":23015,   
"ctx":"listener","msg":"Listening on","attr":{"address":"0.0.0.0"}}
{"t":{"$date":"2021-07-03T11:34:45.075+00:00"},"s":"I",  "c":"NETWORK",  "id":23016,   
"ctx":"listener","msg":"Waiting for connections","attr":{"port":27017,"ssl":"off"}}
.  .  .
````

Getting Pod information:

````shell
$ kubectl describe pod mongo-depl-5fd6b7d4b4-jj4b5
Name:         mongo-depl-5fd6b7d4b4-jj4b5
.  .  .
Events:
  Type    Reason     Age    From               Message
  ----    ------     ----   ----               -------
  Normal  Scheduled  8m21s  default-scheduler  Successfully assigned default/mongo-depl-5fd6b7d4b4-jj4b5 to minikube
  Normal  Pulling    8m20s  kubelet            Pulling image "mongo"
  Normal  Pulled     7m38s  kubelet            Successfully pulled image "mongo" in 42.583008968s
  Normal  Created    7m37s  kubelet            Created container mongo
  Normal  Started    7m37s  kubelet            Started container mongo
````

Another very useful command allows to enter a Pod as a `root` user:

````shell
$ kubectl exec -it mongo-depl-5fd6b7d4b4-jj4b5 -- /bin/bash
root@mongo-depl-5fd6b7d4b4-jj4b5:/# whoami
root
root@mongo-depl-5fd6b7d4b4-jj4b5:/# exit
exit
$
````


## Deleting Deployments

[55:11](https://youtu.be/X48VuDVv0do?t=3311)

````shell
$ kubectl get deployments
NAME         READY   UP-TO-DATE   AVAILABLE   AGE
mongo-depl   1/1     1            1           22m
nginx-depl   1/1     1            1           141m

$ kubectl delete deployment mongo-depl
deployment.apps "mongo-depl" deleted

$ kubectl get pods
NAME                          READY   STATUS        RESTARTS   AGE
mongo-depl-5fd6b7d4b4-jj4b5   0/1     Terminating   0          22m
nginx-depl-58f65d4b6f-hk44c   1/1     Running       0          110m
````

It needs some little time to complete the operation:

````shell
$ kubectl get pods
NAME                          READY   STATUS    RESTARTS   AGE
nginx-depl-58f65d4b6f-hk44c   1/1     Running   0          110m

$ kubectl get replicasets
NAME                    DESIRED   CURRENT   READY   AGE
nginx-depl-58f65d4b6f   1         1         1       111m
nginx-depl-5c8bf76b5b   0         0         0       142m
````


## Applying configuration files

[56:18](https://youtu.be/X48VuDVv0do?t=3378)

We can do all the CRUD operation the similar way on the K8s components (like Deployments, Pods,
Services, etc.). We can specify all the parameters (like Deployment name, image name, etc.) in
the command line but that is impractical. That's why we would usually work with K8s
__configuration files__. 

First create the configuration file:

````shell
$ vi nginx-deployment.yaml
````

Fill it with the content of the file
[`nginx-deployment.yaml`](../fromAuthor/kubernetes-configuration-file-explained/nginx-deployment.yaml).

````shell
$ kubectl apply -f nginx-deployment.yaml
deployment.apps/nginx-deployment created

$ kubectl get pods
NAME                               READY   STATUS    RESTARTS   AGE
nginx-deployment-f4b7bbcbc-gpffv   1/1     Running   0          50s
nginx-deployment-f4b7bbcbc-w9tpc   1/1     Running   0          50s

$ kubectl get deployments
NAME               READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   2/2     2            2           5m45s
````

We see two Pods because we specified `replicas: 2` in the configuration file.

We can change the configuration file and apply it again. In this case K8s will update the
existing Deployment. For example, lets replace `replicas: 2` by `replicas: 1`:

````shell
$ kubectl apply -f nginx-deployment.yaml
deployment.apps/nginx-deployment configured

$ kubectl get deployments
NAME               READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   1/1     1            1           12m

$ kubectl get po
NAME                               READY   STATUS    RESTARTS   AGE
nginx-deployment-f4b7bbcbc-gpffv   1/1     Running   0          12m
````

Here K8s decided itself which Pod to stop.


## Summarize `kubectl` commands

[1:01:14](https://youtu.be/X48VuDVv0do?t=3674)

__CRUD commands:__

- Create Deployment --- `kubectl create deployment [name]`
- Edit Deployment --- `kubectl edit deployment [name]`
- Delete Deployment --- `kubectl delete deployment [name]`

__Status of K8s components:__ `kubectl get nodes | pods | services | replicasets | deployments`

__Debugging Pods:__

- Log to console --- `kubectl logs [pod name]`
- Get interactive terminal --- `kubectl exec -it [pod name] -- /bin/bash`
- Get info about a Pod --- `kubectl describe pod [pod name]`

__Use configuration file for CRUD:__

- Apply a configuration file --- `kubectl apply -f [file name]`
- Delete with configuration file --- `kubectl delete -f [file name]`

----------------------------------------------------------------------------------------------------
# K8s YAML Configuration File

[1:02:03](https://youtu.be/X48VuDVv0do?t=3723)


## Overview

- The three parts of configuration file
- Connecting Services to Deployments and Pods
- Demo


## Three parts of K8s configuration file

See [nginx-deployment.yaml](../fromAuthor/kubernetes-configuration-file-explained/nginx-deployment.yaml)
and [nginx-service.yaml](../fromAuthor/kubernetes-configuration-file-explained/nginx-service.yaml).

`kind: Deployment` and `kind: Service` show what we are going to create.

- First part is `matadata:`
- Second part is specification (`spec:`). It is specific to the kind of the component.
- Third part is `status:` --- automatically generated and added by K8s. This is how K8s
	__continuously__ tracks the desired and the actual states and makes decides about the
	self-healing.

The `status` information is held in the [etcd](index.html#master_node_processes).

If we specify and apply `spec/replicas: 2` but actual is:

````shell
$ kubectl get deployment nginx-deployment -o yaml | less
.  .  .
apiVersion: apps/v1
kind: Deployment
metadata:
.  .  .
  name: nginx-deployment
.  .  .
status:
  availableReplicas: 1
.  .  .
````

Then K8s will see the problem and will try to create a new replica ASAP.


## Format of configuration file

[1:05:38](https://youtu.be/X48VuDVv0do?t=3938)

__YAML__ (a recursive acronym for "__YAML__ Ain't Markup Language"):
[Wikipedia](https://en.wikipedia.org/wiki/YAML) |
[Official site](https://yaml.org/).

It's a good practice to store configuration files the code (see [IAAC, Infrastructure As Code,
concept](https://en.wikipedia.org/wiki/Infrastructure_as_code)).


## Blueprint for Pods (`template`)

[1:06:49](https://youtu.be/X48VuDVv0do?t=4009)

<img src="pict/deployment_abstraction_layers.png" style="float: left; margin: 0 25px 25px 0;" />

Whenever we want to create a Pod we create a Deployment and K8s takes care of the rest.

See [nginx-deployment.yaml](../fromAuthor/kubernetes-configuration-file-explained/nginx-deployment.yaml),
`spec/template:`. The template also has its metadata and specification. So it's a configuration file
inside a configuration file. The latter configuration applies to a Pod, so it is the __blueprint__
for a Pod.

<p style="clear: both;"></p>

## Connecting Services to Deployments and Pods

[1:08:03](https://youtu.be/X48VuDVv0do?t=4083)

This is done using __labels__ and __selectors__. Also see K8s documentation 
[Labels and Selectors](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/).

![](pict/labels_and_selectors.png)

See [nginx-deployment.yaml](../fromAuthor/kubernetes-configuration-file-explained/nginx-deployment.yaml)
and [nginx-service.yaml](../fromAuthor/kubernetes-configuration-file-explained/nginx-service.yaml).

<img src="pict/ports_01.png" style="float: left; margin: 0 25px 25px 0;" />

![](pict/ports_02.png)

So the Service will accept requests on the port `80` and forwards them the to port `8080` of the
Pod.

<p style="clear: both;"></p>

Placing the YAML files into the working accessible directory and applying them:

````shell
$ kubectl apply -f nginx-deployment.yaml
deployment.apps/nginx-deployment unchanged

$ kubectl apply -f nginx-service.yaml
service/nginx-service created
````

Now getting more detailed information about the Pods:

````shell
$ kubectl get pods -o wide
NAME                               READY   STATUS    RESTARTS   AGE   IP           NODE       NOMINATED NODE   READINESS GATES
nginx-deployment-f4b7bbcbc-6kbgw   1/1     Running   0          30h   172.17.0.5   minikube   <none>           <none>
nginx-deployment-f4b7bbcbc-gpffv   1/1     Running   0          31h   172.17.0.6   minikube   <none>           <none>
````

Two pods as we have `replicas: 2`. Looking at the service:

````shell
$ kubectl get services
NAME            TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE
kubernetes      ClusterIP   10.96.0.1        <none>        443/TCP   2d1h
nginx-service   ClusterIP   10.110.173.246   <none>        80/TCP    117s

$ kubectl describe service nginx-service
Name:              nginx-service
.  .  .
Selector:          app=nginx
.  .  .
TargetPort:        8080/TCP
Endpoints:         172.17.0.5:8080,172.17.0.6:8080
.  .  .
````

Now let's look at the status (that is automatically generated):

````shell
$ kubectl get deployment nginx-deployment -o yaml > nginx-deployment-result.yaml

$ less nginx-deployment-result.yaml
````

> This automatically generated configuration contains a lot of runtime data. So if we want to 
> create a blueprint out of it then we need to clean it much.

We can delete the components using configuration files:

````shell
$ kubectl delete -f nginx-deployment.yaml
deployment.apps "nginx-deployment" deleted

$ kubectl delete -f nginx-service.yaml
service "nginx-service" deleted
````

----------------------------------------------------------------------------------------------------
# Complete demo project

[1:16:16](https://youtu.be/X48VuDVv0do?t=4576)



----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
[[BACK](installation.html)]

----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
